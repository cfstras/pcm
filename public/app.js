
// If you are a cross-browser web app and want to use window.localStorage
//hterm.defaultStorage = new lib.Storage.Local()

// If you are a cross-browser web app and want in-memory storage only
hterm.defaultStorage = new lib.Storage.Memory();

// opt_profileName is the name of the terminal profile to load, or "default" if
// not specified.  If you're using one of the persistent storage
// implementations then this will scope all preferences read/writes to this
// name.
var t = new hterm.Terminal("default");
t.decorate(document.querySelector('#terminal'));

t.onTerminalReady = function() {

    // Create a new terminal IO object and give it the foreground.
    // (The default IO object just prints warning messages about unhandled
    // things to the the JS console.)
    var io = t.io.push();

    io.onVTKeystroke = function(str) {
        // Do something useful with str here.
        // For example, Secure Shell forwards the string onto the NaCl plugin.
        console.debug("vtKeystroke", str);
    };

    io.sendString = function(str) {
        // Just like a keystroke, except str was generated by the
        // terminal itself.
        // Most likely you'll do the same this as onVTKeystroke.
        console.debug("sendString", str);
    };

    io.onTerminalResize = function(columns, rows) {
        // React to size changes here.
        // Secure Shell pokes at NaCl, which eventually results in
        // some ioctls on the host.
        console.debug("resize", columns, rows);
    };
    //io.pop();
    // You can call io.push() to foreground a fresh io context, which can
    // be uses to give control of the terminal to something else.  When that
    // thing is complete, should call io.pop() to restore control to the
    // previous io object.
    t.installKeyboard();

    t.io.print('Print a string without a newline');
    t.io.println('Print a string and add CRLF');
    
};

